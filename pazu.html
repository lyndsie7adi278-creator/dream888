<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <title>夢工廠旗艦彈珠台 - 完美不回流版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://static.line-scdn.net/liff/edge/2/sdk.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.15.0/firebase-database-compat.js"></script>
    <style>
        html, body { position: fixed; width: 100%; height: 100%; overflow: hidden; touch-action: none; background: #1a0f0a; margin: 0; }
        .wood-bg { background-color: #d2b48c; background-image: url('https://www.transparenttextures.com/patterns/wood-pattern-polished.png'); }
        .machine-frame {
            border: 12px solid #5d2e17; border-radius: 40px;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.5), 0 20px 40px rgba(0,0,0,0.8);
            background: #fdf5e6; position: relative; overflow: hidden;
        }
        .plunger-outer {
            width: 45px; height: 180px; background: #8b4513; border: 4px solid #422006;
            border-radius: 22px; display: flex; justify-content: center; align-self: flex-end; margin-bottom: 20px;
        }
        #p-stick { width: 8px; height: 100px; background: #94a3b8; border-radius: 4px; margin-top: 5px; position: relative; }
        #p-knob {
            position: absolute; bottom: -30px; left: 50%; transform: translateX(-50%);
            width: 42px; height: 42px; background: radial-gradient(circle at 30% 30%, #ef4444, #7f1d1d);
            border-radius: 50%; box-shadow: 0 4px 10px rgba(0,0,0,0.6); cursor: pointer;
        }
    </style>
</head>
<body class="flex flex-col items-center wood-bg">

    <div class="w-full max-w-[400px] p-4 flex justify-between items-center text-[#422006] font-black">
        <div class="bg-white/40 px-5 py-2 rounded-2xl border border-amber-900/20 shadow-sm">
            <p class="text-[10px] uppercase">Point</p>
            <p id="userPoints" class="text-xl">---</p>
        </div>
        <div class="bg-white/40 px-5 py-2 rounded-2xl border border-amber-900/20 text-right shadow-sm">
            <p class="text-[10px] uppercase">Ball</p>
            <p id="gameState" class="text-xl">0 / 5</p>
        </div>
    </div>

    <div class="flex items-stretch gap-4 px-2 h-[82vh] w-full max-w-[450px]">
        <div class="machine-frame flex-grow">
            <canvas id="gameCanvas"></canvas>
        </div>
        <div class="plunger-side plunger-outer">
            <div id="p-stick">
                <div id="p-knob"></div>
            </div>
        </div>
    </div>

    <div id="resultModal" class="fixed inset-0 bg-black/95 z-50 hidden flex items-center justify-center p-6 backdrop-blur-md">
        <div class="bg-[#fdf5e6] w-full max-w-sm rounded-[3rem] p-10 border-[10px] border-[#5d2e17] text-center shadow-2xl">
            <h2 class="text-[#5d2e17] font-black text-2xl">本次總得分</h2>
            <h1 id="finalScore" class="text-7xl font-black text-red-600 my-6">0</h1>
            <button onclick="location.reload()" class="w-full py-5 rounded-2xl font-black bg-[#5d2e17] text-white text-xl active:scale-95 transition">再挑戰一次 (10點)</button>
        </div>
    </div>

    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyDPGEIwCKyYxz6TYdxmkwAxIWjfQI8Awco",
            authDomain: "dream8-7b161.firebaseapp.com",
            databaseURL: "https://dream8-7b161-default-rtdb.firebaseio.com",
            projectId: "dream8-7b161",
            storageBucket: "dream8-7b161.firebasestorage.app",
            messagingSenderId: "606218522479",
            appId: "1:606218522479:web:2737643db3de735af7e29a"
        };
        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let user = { id: "", points: 0 };
        let ball = { x: 0, y: 0, vx: 0, vy: 0, r: 8.5, active: false, hasLeftLane: false };
        let settledBalls = [];
        let holeOccupancy = Array(10).fill(0);
        let pins = [];
        let holes = [10, 20, 50, 100, 30, 30, 100, 50, 20, 10];
        let score = 0, usedBalls = 0, isDragging = false, startY = 0, dragOffset = 0;
        let arcCenterX, arcCenterY, arcRadius, laneX, holeWidth;

        function resize() {
            const container = document.querySelector('.machine-frame');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            laneX = canvas.width - 40;
            holeWidth = laneX / 10;
            arcCenterX = canvas.width / 2;
            arcCenterY = 145; 
            arcRadius = canvas.width / 2 - 5;
            initPins();
            resetBall();
        }

        function initPins() {
            pins = [];
            const pinAreaTop = 200;
            const pinAreaBottom = canvas.height - 120;
            for (let i = 0; i < 7; i++) {
                let rowCount = (i % 2 === 0) ? 6 : 7;
                for (let j = 0; j < rowCount; j++) {
                    const randX = (Math.random() - 0.5) * 15;
                    const randY = (Math.random() - 0.5) * 10;
                    pins.push({ 
                        x: (i % 2 === 0 ? 35 : 20) + j * (laneX/rowCount) + randX, 
                        y: pinAreaTop + i * 45 + randY 
                    });
                }
            }
        }

        function resetBall() {
            ball.x = canvas.width - 20;
            ball.y = canvas.height - 40;
            ball.vx = 0; ball.vy = 0; ball.active = false; ball.hasLeftLane = false;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = "#8b4513"; ctx.lineWidth = 6; ctx.lineCap = "round";

            // 1. 視覺導軌
            ctx.beginPath();
            ctx.moveTo(laneX, canvas.height); ctx.lineTo(laneX, arcCenterY);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(arcCenterX, arcCenterY, arcRadius, Math.PI, 0, false);
            ctx.stroke();

            // 2. 計分槽隔板
            for(let i=0; i<=holes.length; i++) {
                ctx.beginPath(); ctx.lineWidth = 4;
                ctx.moveTo(i * holeWidth, canvas.height - 100); 
                ctx.lineTo(i * holeWidth, canvas.height); ctx.stroke();
            }
            holes.forEach((s, i) => {
                ctx.fillStyle = "#8b4513"; ctx.font = "bold 10px Arial"; ctx.textAlign = "center";
                ctx.fillText(s, i * holeWidth + holeWidth/2, canvas.height - 10);
            });

            // 3. 釘子
            ctx.fillStyle = "#cd853f";
            pins.forEach(p => { 
                ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI * 2); ctx.fill(); 
                ctx.fillStyle = "#fff8"; ctx.beginPath(); ctx.arc(p.x-1, p.y-1, 1, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = "#cd853f";
            });

            // 4. 球體
            settledBalls.forEach(b => drawBall(b.x, b.y));
            if (usedBalls < 5) drawBall(ball.x, ball.y);

            update();
            requestAnimationFrame(draw);
        }

        function drawBall(x, y) {
            let g = ctx.createRadialGradient(x-3, y-3, 1, x, y, 8.5);
            g.addColorStop(0, '#ff6b6b'); g.addColorStop(1, '#8b0000');
            ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x, y, 8.5, 0, Math.PI*2); ctx.fill();
        }

        function update() {
            if (!ball.active) return;

            const subSteps = 15;
            const gravity = 0.22;

            for(let s=0; s<subSteps; s++) {
                ball.vy += gravity / subSteps;
                ball.x += ball.vx / subSteps;
                ball.y += ball.vy / subSteps;

                // --- A. 計分槽物理隔離 ---
                if (ball.y > canvas.height - 100 && ball.x < laneX) {
                    const idx = Math.floor(ball.x / holeWidth);
                    const leftWall = idx * holeWidth + ball.r;
                    const rightWall = (idx + 1) * holeWidth - ball.r;
                    if (ball.x < leftWall) { ball.x = leftWall; ball.vx *= -0.3; }
                    if (ball.x > rightWall) { ball.x = rightWall; ball.vx *= -0.3; }
                }

                // --- B. 單向閥門物理牆 (核心修正) ---
                // 判斷球是否已經成功飛出發射道
                if (ball.x < laneX - ball.r) { ball.hasLeftLane = true; }

                if (ball.hasLeftLane) {
                    // 如果球已經在遊戲區，發射道的左牆變成雙面實體，絕對進不去
                    if (ball.x > laneX - ball.r && ball.y > arcCenterY) {
                        ball.x = laneX - ball.r;
                        ball.vx *= -0.5;
                    }
                } else {
                    // 如果還在發射道內，鎖死發射道的邊界
                    if (ball.x < laneX + ball.r && ball.y > arcCenterY) {
                        ball.x = Math.max(laneX + ball.r, ball.x);
                        ball.vx = 0;
                    }
                }

                // --- C. 頂部圓弧反射 ---
                const dx = ball.x - arcCenterX;
                const dy = ball.y - arcCenterY;
                const dist = Math.sqrt(dx*dx + dy*dy);

                if (ball.y < arcCenterY && dist + ball.r > arcRadius) {
                    const nx = dx / dist; const ny = dy / dist;
                    ball.x = arcCenterX + nx * (arcRadius - ball.r);
                    ball.y = arcCenterY + ny * (arcRadius - ball.r);
                    const dot = ball.vx * nx + ball.vy * ny;
                    if (dot > 0) {
                        ball.vx = (ball.vx - 1.8 * dot * nx) * 0.98;
                        ball.vy = (ball.vy - 1.8 * dot * ny) * 0.98;
                    }
                }

                // --- D. 釘子碰撞 ---
                pins.forEach(p => {
                    const pdx = ball.x - p.x, pdy = ball.y - p.y;
                    const pdist = Math.sqrt(pdx*pdx + pdy*pdy);
                    if (pdist < ball.r + 3) {
                        const angle = Math.atan2(pdy, pdx);
                        const speed = Math.sqrt(ball.vx**2 + ball.vy**2);
                        ball.vx = Math.cos(angle) * (speed * 0.75 + 0.4);
                        ball.vy = Math.sin(angle) * (speed * 0.75 + 0.4);
                    }
                });

                // 邊界
                if (ball.x < ball.r) { ball.x = ball.r; ball.vx *= -0.5; }
                if (ball.y < ball.r) { ball.y = ball.r; ball.vy *= -0.5; }
            }

            // 結算
            if (ball.y > canvas.height - 35 && ball.x < laneX) {
                const idx = Math.floor(ball.x / holeWidth);
                score += holes[Math.min(idx, 9)];
                const stack = holeOccupancy[idx];
                settledBalls.push({ x: idx * holeWidth + holeWidth/2, y: canvas.height - 20 - (stack * 18) });
                holeOccupancy[idx]++;
                usedBalls++;
                document.getElementById('gameState').innerText = `${usedBalls} / 5`;
                resetBall();
                if (usedBalls >= 5) {
                    setTimeout(() => {
                        document.getElementById('finalScore').innerText = score;
                        document.getElementById('resultModal').classList.remove('hidden');
                    }, 800);
                }
            }

            if (ball.y > canvas.height && ball.x >= laneX) resetBall();
        }

        const knob = document.getElementById('p-knob');
        const stick = document.getElementById('p-stick');

        knob.addEventListener('touchstart', (e) => {
            if (ball.active || usedBalls >= 5) return;
            isDragging = true; startY = e.touches[0].clientY;
            e.preventDefault();
        }, { passive: false });

        window.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            dragOffset = Math.max(0, Math.min(100, e.touches[0].clientY - startY));
            stick.style.transform = `translateY(${dragOffset}px)`;
            e.preventDefault();
        }, { passive: false });

        window.addEventListener('touchend', () => {
            if (!isDragging) return;
            isDragging = false;
            if (dragOffset > 20) {
                if (usedBalls === 0 && user.points < 10) return alert("點數不足！");
                if (usedBalls === 0) db.ref('users/' + user.id).update({ points: user.points - 10 });
                ball.active = true;
                ball.hasLeftLane = false;
                ball.vy = -(dragOffset / 3.2); 
                ball.vx = (Math.random() - 0.5) * 0.5; 
            }
            stick.style.transform = `translateY(0px)`;
            dragOffset = 0;
        });

        async function init() {
            try {
                await liff.init({ liffId: "2008968610-8dLoGQie" });
                if (liff.isLoggedIn()) {
                    const p = await liff.getProfile();
                    user.id = p.userId;
                    db.ref('users/' + user.id + '/points').on('value', s => {
                        user.points = s.val() || 0;
                        document.getElementById('userPoints').innerText = user.points.toLocaleString();
                    });
                }
            } catch (e) {}
        }

        window.onload = () => { init(); resize(); draw(); };
        window.onresize = resize;
    </script>
</body>
</html>
